GOAT       -> PROC+
PROC       -> "proc" id "(" PARAMS ")" DECL* "begin" STMT+ "end"
PARAMS     -> (PARAM ",")* PARAM | ε

PARAM      -> PASSBY TYPE id
PASSBY     -> "val" | "ref"
TYPE       -> "bool" | "float" | "int"

DECL       -> TYPE id DECL_SHAPE ";"
DECL_SHAPE -> ε | "[" int "]" | "[" int "," int "]"

STMT       -> ASGN | READ | WRITE | CALL | IF | WHILE 
ASGN       -> VAR ":=" EXPR ";"
VAR        -> id EXPR_SHAPE
EXPR_SHAPE -> ε | "[" EXPR "]" | "[" EXPR "," EXPR "]"
READ       -> "read" VAR ";"
WRITE      -> "write" EXPR ";"
CALL       -> "call" id "(" EXPRS ")" ";"
EXPRS      -> (EXPR ",")* EXPR | ε
IF         -> "if" EXPR "then" STMT+ MAYBE_ELSE "fi" 
MAYBE_ELSE -> "else" STMT+ | ε
WHILE      -> "while" EXPR "do" STMT+ "od"

EXPR       -> VAR | CONST | "(" EXPR ")" | EXPR BINOP EXPR | UNOP EXPR
CONST      -> int | float | BOOL | STRING
BOOL       -> "true" | "false"
BINOP      -> "+" | "-" | "*" | "/"
            | "<=" | "<" | "=" | "!=" | ">" | ">="
            | "&&" | "||"
UNOP       -> "!" | "-"




Key:
* Uppercase strings (e.g. TYPE) are grammar nonterminals
* strings in double quotes (e.g. "int") are terminals representing reserved keywords or operators (or structural terminals like "(", ")", "[", "]", and ";").
* lowercase strings without quotes (e.g. int) are terminals representing tokens (so an example of int is the string "2"). These will be handled by parsec’s internal lexer, see below for token definitions.
* The symbols * and + (e.g. STMT+) are grammar shorthands that map easily to parsec combinators (* --> `many`, + --> `many1` I think).
* The parens and * in PARAMS and EXPRS are also shorthands that can be captured by other parser combinators---I think it’s called `sepBy` in this case.
* Likewise we may be able to capture the similarity between DECL_SHAPE and EXPR_SHAPE using a combinator we define ourselves.
* We haven’t built the precedence and associativity rules for operators into the EXPR grammar (it is currently ambiguous); but this is something we can configure in parsec (see spec for precedence and associativity details).
* We also have not included anything about comments but skipping comments is easily configurable in the parsec tokenizer.


Tokens:
id -> [a-zA-Z][a-zA-Z0-9_’]*
int -> [0-9]+
float -> [0-9]+\.[0-9]+
string -> "[^"\n\t]*"
To clarify, you ARE allowed to have the character ‘\’ followed by the character ‘n’ but not the single character ‘\n’ (newline). Also, not sure if this is really something we can handle during tokenisation (not sure if parsec tokenisers support string literal tokens) so we may have to put it in the grammar.

Some initial sketches of part of the AST type:

data Stmt = Asgn ShapedId Expr | Read ShapedId | Write Expr | Call Id [Expr] | If Expr [Stmt] | IfElse Expr [Stmt] [Stmt] | While Expr [Stmt]

data Id = Id String
data ShapedId = IdVar Id | IdArray Id Expr | IdMatrix Id Expr Expr

And for parsing statements:

parseStmt :: Parser -> Stmt
parseStmt = do parseAsgn
                 <|> parseRead
                 <|> parseWrite
                 <|> parseCall
                 <|> parseIf
                 <|> parseWhile

parseProc = do
    pReserved "proc"
    name <- pIdentifier
    params <- parens $ sepBy (char ",") parseParam
    decls <- many parseDecl
    pReserved "begin"
    stmts <- many1 parseStmt
    pReserved "end"
    return (Procedure name params decls stmts)

parseParam = do
    passBy <- parsePassBy
    type <- parseType
    name <- pIdentifier
    return (Param passBy type name)
parsePassBy :: Parser PassBy
parsePassBy
  =  do {reserved "val"; return Val}
<|> do {reserved "ref"; return Ref}

PROC → "proc" id "(" PARAMS ")" DECL* "begin" STMT+ "end"    { Procedure $1 $2 $3 $4 }
